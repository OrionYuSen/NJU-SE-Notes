### 嵌入式复习

#### 1 嵌入式系统简介

##### 1.1 定义

嵌入式系统是**以应用为中心**，**以计算机技术为基础**，软硬件**可裁减**，适用于应用系统对**功能、可靠性、成本、体积、功耗**有严格要求的专用计算机系统。

##### 1.2 特点

1. 嵌入式系统通常是**形式多样、面向特定应用**的
2. 嵌入式系统得到**多种类型的处理器和处理器体系结构**的支持
3. 嵌入式系统通常极其关注**成本**
4. 嵌入式系统有**实时性和可靠性**的要求
5. 嵌入式系统使用的操作系统一般是**适应多种处理器、可剪裁、轻量型、实时可靠、可固化**的嵌入式操作系统
6. 嵌入式系统开发需要**专门工具和特殊方法**

形式多样；处理器，操作系统，开发方式；成本，实时性，可靠性

##### 1.3 分类

1. 按嵌入式处理器的位数来分类
2. 按应用来分类
3. 按速度分类（强实时，一般实时，弱实时）
4. 按确定性来分类（硬实时，软实时）
5. 按嵌入式系统软件复杂程度来分类

##### 1.4 典型应用

- 嵌入式人工智能
- 自动驾驶
- 智能家居

##### 1.5 组成

1. 嵌入式系统一般由**嵌入式硬件和软件**组成
2. 硬件以**微处理器**为核心集成存储器和系统专用的**输入/输出设备**
3. 软件包括：**初始化代码及驱动、嵌入式操作系统和应用程序**等，这些软件有机地结合在一起，形成系统特定的一体化软件。

自下而上：系统硬件，驱动，内核，中间件，应用软件

##### 1.6 IoT

设备＋电子元件，软件，传感器 互联 收集并交换数据

##### 1.7 CPS，信息物理系统

A cyber-physical system (CPS) is a mechanism controlled or monitored by computer-based algorithms, tightly integrated with the internet and its users. 

计算进程和物理进程的深度融合。由嵌入式，物联网，控制器组成。

典型结构：

<img src="C:\Users\mayusen\Desktop\嵌入式系统概论\CPS_typical_structure.png" alt="CPS_typical_structure" style="zoom: 33%;" />

#### 2 嵌入式系统设计

##### 2.1 挑战

1. 需要多少硬件？
2. 如何满足时限要求，如何处理理多项功能在时间上的协调一致关系？
3. 如何降低系统的功耗？
4. 如何设计以保证系统可升级？
5. 如何保证系统可靠地工作？

硬件，实时性，功耗，可靠性，可升级（可拓展性）

##### 2.2 传统开发过程

1. 传统软硬件设计过程的基本特征:
   1. 系统在一开始就被划分为软件和硬件两大部分
   2. 软件和硬件独立进行行开发设计
   3. "Hardware first" approach often adopted
2. 隐含的一些问题:
   1. 软硬件之间的交互受到很大限制：凭经验划分软硬件、软硬件之间的相互**性能影响**很难评估
   2. 系统集成相对滞后，越后期发现的问题可能会导致越严重的开销
3. 因此：设计**质量差**、设计**修改代价高**、研制**周期不能有保障**

##### 2.3 软硬件协同设计

1. 指一种专用系统的设计，该系统由几个**专用集成电路**组成，这些集成电路与通用处理器上的软件过程配合使用
2. 通过**并发设计**来利用硬件和软件的协同作用
3. 提供分析方法，提高可预测性；提供综合方法快速评估方案可行性
4. 它从新兴学科(90年代初)发展为主流技术(今天)

##### 2.4 软硬件划分

1. 嵌入式系统的设计涉及硬件与软件部件，设计中必须决定什么功能由硬件实现，什么功能由软件实现。
2. 硬件和软件具有双重性
3. 软硬件变动对系统的决策造成影响
4. 划分和选择需要考虑多种因素
5. 硬件和软件的双重性是划分决策的前提

###### 2.4.1 软件

1. 操作系统功能：任务调度、资源管理、设备驱动
2. 协议栈:TCP/IP
3. 应用软件框架
4. 除基本系统、物理理接口、基本逻辑电路，许多由硬件实现的功能都可以由软件实现。

###### 2.4.2 双重性

1. 算法：加密/解密、编码/解码、压缩/解压。
2. 数学运算:浮点运算、FFT。

#### 3 嵌入式系统硬件

##### 3.1 冯诺依曼与哈佛结构

###### 3.1.1 冯诺依曼

1. 存储器保存数据，指令。
2. 中央处理器(CPU)从内存中获取指令。

###### 3.1.2 哈佛

1. Harvard 不能使用自我修改的代码。
2. 数据和程序存储在不同的空间中。
3. Harvard 允许同时进行两次内存提取。
4. 大多数DSP(数据信号处理，Digital Signal Process)使用 Harvard 架构来传输数据：
   1. 更大的内存带宽
   2. 更可预测的带宽

##### 3.2 CISC和RISC

1. Complex instruction set computer (CISC): 复杂指令集计算机：许多寻址模式、多种操作，不等长，指令操作能力更强
2. Reduced instruction set computer (RISC): 精简指令集计算机：加载/存储、可传递指令，登场

##### 3.3 流水线技术

- 加快指令执行速度
- 结构冲突（多条指令共用一个资源），数据冲突（前后指令数据存在依赖），分支跳转会降低速度
- 优先指令集消除小规模跳转以获得最好的效率

##### 3.4 处理器分类

1. 嵌入式微处理器种类繁多，按位数可分为4位、8位、16位、32位和64位。
2. 根据功能不同，嵌入式微处理器分为四种：
   1. 嵌入式微处理单元(MPU) 通用计算机
   2. 嵌入式微控制器(MCU) 将计算机系统的硬件集成到一块芯片中
   3. 嵌入式DSP处理器 信号处理
   4. 嵌入式SoC 集成度高

##### 3.5 处理器选型

- Step 1: 列出所需的硬件接口
- Step 2: 检查软件架构
- Step 3: 选择架构
- Step 4: 确定内存需求
- Step 5: 开始寻找微控制器
- Step 6: 检查成本和功率约束
- Step 7: 检查零件可用性
- Step 8: 选择开发套件
- Step 9: 研究编译器和工具
- Step 10: 开始实验

##### 3.6 存储架构

1. 平面单空间
2. 分段式
3. 组切换
4. 多类型存储区
5. 虚拟内存
6. cache

##### 3.7 ROM种类和选型

ROM,PROM,EPROM

##### 3.8 RAM种类和选型

1. DRAM便宜，慢，大，简单，需要不断刷新，因为存储在电容器中
2. SRAM贵，快，小，复杂

##### 3.9 Flash种类和选型

1. NOR(放代码)
   1. 字可读取。
   2. 逐块擦除。
2. NAND（放文件）:
   1. 按页读取(512-4K字节)。
   2. 逐块擦除。
3. NAND便宜，写速度更快，读慢。

##### 3.10 总线类型

单总线，双总线（CPU和主存），多总线（I/O总线）

##### 3.11 忙等IO和中断IO

中断更加高效，忙等需要轮询

##### 3.12 独立IO端口和内存映射IO

1. 内存映射I/O的优点可总结为：
   1. 在内存映射的I/O模式下，设备控制寄存器只是内存中的变量，并且可以与其他变量一样用C寻址。因此，可以完全用C语言编写I/O设备驱动程序。
   2. 在这种模式下，不需要特殊的保护机制即可阻止用户进程执行I/O操作。
2. 内存映射I/O模式的缺点可以总结为：
   1. 当前大多数嵌入式处理器都支持cache。cache储存控制寄存器无法反映实时状态。为了防止这种情况，必须为硬件提供选择性禁用缓存的功能。这将增加嵌入式系统中硬件和软件的复杂性。
   2. 如果只有一个地址空间，则所有内存模块和所有I/O设备都必须检查所有内存引用，以便确定要响应的IO。这会严重影响系统性能。

#### 4 嵌入式系统软件

##### 4.1 软件基础知识

###### 4.1.1 特点

内存有限，CPU保守，操作系统RTOS，要求确定性，开发过程中执行代价大，每一台嵌入式设备都不同

###### 4.1.2 体系结构

1. 轮询
2. 有限状态机
3. 带中断的轮询
4. 仅有中断
5. 功能队列调度
6. 实时操作系统(RTOS)

##### 4.2 RTOS概念

###### 4.2.1 特点

1. 可靠性
2. 满足应用需要的裁剪能力
3. 更快
4. 减少内存需求
5. 为实时嵌入式系统提供可裁剪的调度策略
6. 支持**无盘化**嵌入式系统，允许从ROM或RAM上引导并运行
7. 对不同硬件平台具有更好的**可移植性**。

##### 4.3 RTOS任务管理

###### 4.3.1 进程，线程，任务

进程：资源分配的最小单位；线程：程序执行的最小单位；任务：一个抽象，可以对应进程也可以对应线程

###### 4.3.2 任务控制块

- 任务ID
- 任务状态(运行，就绪，已阻止)
- 任务优先级
- 任务起始地址
- 任务堆栈
- 任务CPU寄存器
- 任务数据指针
- 任务时间

###### 4.3.3 任务状态

就绪 运行 等待资源

###### 4.3.4 RMS, Rate Monotonic Scheduling

静态调度，如果存在可行调度，那么RMS一定有。很方便

###### 4.3.5 EDD, Earliest Due Date

使最大延迟最小的算法

###### 4.3.6 EDF，Earliest Deadline First

###### 4.3.7 RMS和EDF比较

1. RMS优点:调度决策更简单(固定优先级与EDF所需的动态优先级。EDF调度程序必须维护按优先级排序的就绪任务列表。)
2. EDF优点:
   1. 由于EDF是关于最大延迟的最优，也是关于可行性的最优选择。 RMS仅是关于可行性的最优选择。对于不可行的计划，RMS会完全阻止优先级较低的任务，从而导致无限的最大延迟。
   2. EDF可以充分利用CPU，RMS不行
   3. EDF实际上减少了抢占，因此减少了上下文切换的开销。
   4. 截止时间可能与周期不同。
3. RMS是静态调度，而且已经证明如果存在静态调度策略，那么通过RMS也可以得到，所以RMS一定是最优的。而且RMS简单可预测。

###### 4.3.8 PIP，Priority Inheritance Protocol

如果任务A因为资源block了优先级更高的任务B，那么任务A会继承任务B的优先级

###### 4.3.9 死锁

###### 4.3.10 PCP, Priority Ceiling Protocol

每个资源都有Priority Ceiling，Priority Ceiling是请求此资源的任务中最高的priority。

一个任务请求带锁的资源，只有当它的priority大于所有现在正在被使用的资源的priority ceiling时才能成功。

原理：priority ceiling即现在被block的最高优先级的任务，只有你的优先级比现在被block的最高优先级的任务还高，才能获得资源。

###### 4.3.11 OSRdyGrp，OSRdyTbl[8], OSUnMapTbl[256]

OSRdyGrp表示优先级的前三位，OSRdyTbl[n]表示优先级后三位。组成六位的优先级。

OSUnMapTbl表示离右端最近的1的位置，因为前两个变量越往右越优先

###### 4.3.12 Context切换

入栈，恢复，执行，返回（可能要记录中断次数，调用OSInt()）

###### 4.3.13 ECB,  Event Control Block

⼀个任务或ISR可以通过事件控制块ECB（信号量、邮箱或消息队列）向另外的任务发信号

###### 4.3.14 同步与互斥

临界区，通过打开/关闭中断的方式体现。可以直接关，也可以把中断状态入栈/保存在局部变量中

###### 4.3.15 信号量

标志资源是否还有剩余，除此之外还需要维护一个等待任务列表

###### 4.3.16 消息邮箱

发送数据指针

###### 4.3.17 消息队列

发送多个数据指针

以上三个都需要用ECB包装

##### 4.4 RTOS存储管理

实模式，分区，区内有多个大小相同的块

MCB，Memory Control Block用来管理块，记录了块的信息

##### 4.5 嵌入式系统程序设计

###### 4.5.1 交叉开发

在宿主机和目标机上开发。宿主机一般为通用计算机，目标机为实际运行环境或仿真器，软硬件资源较有限。

- 交叉编译和链接：在宿主机开发，然后编译和链接为可以在目标机上运行的二进制文件。
- 交叉调试：宿主机运行调试程序，调试程序和被调试进程通过串口或者网络进行通信。目标机上会有某种形式的调试代理（软件或硬件设备）与调试器配合完成调试工作。

###### 4.5.2 常用嵌入式开发工具

Keil(单片机ide)，xshell(串口助手)，STM32Cube(STMide)

##### 4.6 RTOS μcOS-Ⅱ 确保任务实时性的机制

- 任务调度时总是选择就绪任务中优先级最高的一个运行
- 允许任务间的抢占
- 具有优先级的中断机制
- 有确定性的任务调度/切换时间和中断延迟
- 精度高的时钟节拍产生时钟中断
- 信号量、互斥量、信箱、消息队列等任务间通信机制

#### 5 BSP, Board Support Package

##### 5.1 嵌入式系统的启动过程

###### 5.1.1 上电复位、板级初始化阶段

1. 嵌⼊式系统上电复位后完成板级初始化⼯作。
2. 板级初始化程序具有完全的硬件特性，⼀般采⽤汇编语⾔实现。不同的嵌⼊式系统，板级初始化时要完成的⼯作具有⼀定的特殊性，但以下⼯作⼀般是必须完成的：
   1. CPU中堆栈指针寄存器的初始化。
   2. BSS段(Block Storage Space表示未被初始化的数据)的初始化。
   3. CPU芯⽚级的初始化：中断控制器、内存等的初始化。

###### 5.1.2 系统引导

1. 根据需要分别进⼊系统软件引导阶段或系统升级阶段。
2. 软件可通过测试通信端⼝数据或判断特定开关的⽅式分别进⼊不同阶段。

系统引导有几种情况：

1. 将系统软件从NOR Flash中读取出来加载到RAM中运⾏：这种⽅式可以解决成本及Flash速度⽐RAM慢的问题。软件可压缩存储在Flash中。
2. 不需将软件引导到RAM中⽽是让其直接在NorFlash上运⾏，进⼊系统初始化阶段。
3. 将软件从外存(如NandFlash、CF卡、MMC等)中读取出来加载到RAM中运⾏：这种⽅式的成本更低。

###### 5.1.3 系统升级

1. 进⼊系统升级阶段后系统可通过⽹络进⾏远程升级或通过串⼝进⾏本地升级。
2. 远程升级⼀般⽀持TFTP、FTP、HTTP等⽅式。
3. 本地升级可通过Console⼝使⽤超级终端或特定的升级软件进⾏。

###### 5.1.4 系统初始化

1. 在该阶段进⾏操作系统等系统软件各功能部分必需的初始化⼯作，如根据系统配置初始化数据空间、初始化系统所需的接⼝和外设等。
2. 系统初始化阶段需要按特定顺序进⾏，如⾸先完成内核的初始化，然后完成⽹络、⽂件系统等的初始化，最后完成中间件等的初始化⼯作。

###### 5.1.5 应用初始化

在该阶段进⾏应⽤任务的创建，信号量、消息队列的创建和与应⽤相关的其它初始化⼯作。

###### 5.1.6 多任务运行

各种初始化⼯作完成后，系统进⼊多任务状态，操作系统按照已确定的算法进⾏任务的调度，各应⽤任务分别完成特定的功能。

##### 5.2 BSP

一段启动代码，但是和BIOS功能有区别。

###### 5.2.1 BSP中的驱动

1. 抽象物理设备或虚拟设备的功能软件，⽤于管理这些设备的操作。
2. 驱动程序的基本功能
   1. 对设备初始化和释放
   2. 对设备进⾏管理
   3. 读取应⽤程序传送给设备⽂件的数据，并回送应⽤程序的请求数据
   4. 检测和处理设备出现的错误

###### 5.2.2 BSP与BIOS/UEFI区别

1. BIOS主要是负责在电脑开启时检测、初始化系统设备(设置栈指针，中断分配，内存初始化..)、装⼊操作系统并调度操作系统向硬件发出的指令。 UEFI,"统⼀的可扩展固件接⼝",旨在代替BIOS, 提⾼软件互操作性和解决BIOS的局限性。
2. BSP是和操作系统绑在⼀起运⾏，尽管BSP的开始部分和BIOS所做的⼯作类似，但是 **BSP还包含和系统有关的基本驱动** 。
3. BIOS程序是⽤户不能更改，编译编程的，只能对参数进⾏修改设置，但是**程序员还可以编程修改BSP**，在BSP中任意添加⼀些和系统⽆关的驱动或程序，甚⾄可以把上层开发的统统放到BSP中
4. 不同的嵌入式系统对应不同的BSP，BIOS更加通用

###### 5.2.3 BSP的特点

1. 硬件相关性：因为嵌⼊式实时系统的硬件环境具有应⽤相关性，所以，作为⾼层软件与硬件之间的接⼝，BSP必须为操作系统提供操作和控制具体硬件的⽅法。
2. 操作系统相关性：不同的操作系统具有各⾃的软件层次结构，因此，不同的操作系统具有特定的硬件接⼝形式。

###### 5.2.3 另一种视角的嵌入式系统初始化

5.2.3.1片级初始化

1. 主要完成CPU的初始化
   1. 设置CPU的核⼼寄存器和控制寄存器
   2. CPU核⼼⼯作模式
   3. CPU的局部总线模式等
2. ⽚级初始化把CPU从上电时的缺省状态逐步设置成为系统所要求的⼯作状态
3. 这是⼀个纯硬件的初始化过程初始化过程

5.2.3.2 板级初始化

1. 完成CPU以外的其他硬件设备的初始化
2. 同时还要设置某些软件的数据结构和参数，为随后的系统级初始化和应⽤程序的运⾏建⽴硬件和软件环境
3. 这是⼀个同时包含软硬件两部分在内的初始化过程

5.2.3.3 系统级初始化

1. 这是⼀个以软件初始化为主的过程，主要进⾏操作系统初始化
2. BSP将控制转交给操作系统，由操作系统进⾏余下的初始化操作：
   1. 包括加载和初始化与硬件⽆关的设备驱动程序
   2. 建⽴系统内存区
   3. 加载并初始化其他系统软件模块(如⽹络系统、⽂件系统等)
3. 最后，操作系统创建应⽤程序环境并将控制转交给应⽤程序的⼊⼝

##### 5.3 Bootloader

###### 5.3.1 RTOS的引导模式

1. 操作系统引导概念：将操作系统装⼊内存并开始执⾏的过程。
2. 按时间效率和空间效率不同的要求，分为两种模式：
   1. 不需要BootLoader的引导模式：时间效率⾼，系统快速启动，直接在NOR flash或ROM系列⾮易失性存储介质中运⾏，但不满⾜运⾏速度的要求。
   2. 需要BootLoader的引导模式：节省空间，牺牲时间，适⽤于硬件成本低，运⾏速度快，但启动速度相对慢

###### 5.3.2 Bootloader概念

1. 嵌⼊式系统中的 OS 启动加载程序
2. 引导加载程序
   1. 包括固化在固件(firmware)中的 boot 代码(可选)，和Boot Loader两⼤部分
   2. 是系统加电后运⾏的第⼀段软件代码
3. 相对于操作系统内核来说，它是⼀个硬件抽象层

###### 5.3.3 Bootloader启动过程

1. 没 BIOS 那样的固件程序：有的嵌⼊式 CPU 也会内嵌⼀段短⼩的启动程序
2. 系统的加载启动任务就完全由 Boot Loader 来完成
   1. ARM7TDMI中，系统在上电或复位时从地址 0x00000000 处开始执⾏
   2. 这个地址是Boot Loader 程序
3. 存储位置
   1. 按地址随机存取的永久性记忆存储器
   2. ⽀持NANDFlash启动的SOC
4. 复制过程
   1. 硬件⽅式
   2. 软件⽅式
   3. 内存映射

###### 5.3.4 Bootloader单阶段/多阶段

###### 5.3.5 Bootloader操作模式

启动加载和下载模式。下载模式一般第一次使用，先下载到ram，然后写到FLASH类存储设备中。

###### 5.3.6 Bootloader与主机的通信设备和协议

串口，xmodem/ymodem/zmodem，TFTP

#### 6 嵌入式系统建模(FSM)

##### 6.1 状态模型（单线程）

###### 6.1.1 Mealy FSM

输出由当前状态和输入一起决定，硬件timing实现复杂

###### 6.1.2 Moore FSM

输出由当前状态决定，容易实现

##### 6.2 层次模型
